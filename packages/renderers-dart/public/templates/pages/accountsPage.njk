{% extends "layout.njk" %}
{% import "macros.njk" as macros %}

{% block main %}
{{ imports }}

/// Generated account class for {{ account.name | pascalCase }}.
///
{% if account.docs.length > 0 %}
{% for doc in account.docs %}
/// {{ doc }}
{% endfor %}
{% endif %}
class {{ account.name | pascalCase }} {
  {% if account.size != null %}
  /// The size of this account.
  static const int size = {{ account.size }};
  {% endif %}

  {% if account.discriminator %}
  /// The discriminator bytes for this account.
  static final Uint8List discriminator = Uint8List.fromList([
    {% for byte in account.discriminator %}{{ byte }}{% if not loop.last %}, {% endif %}{% endfor %}
  ]);
  {% endif %}

  {% for nestedStruct in typeManifest.nestedStructs %}
  {{ nestedStruct }}
  {% endfor %}

  {{ typeManifest.type | safe | replace('class ' + account.name | pascalCase, '') | trim }}

  /// Creates a [{{ account.name | pascalCase }}] from its bytes representation.
  static {{ account.name | pascalCase }} fromBytes(Uint8List data) {
    final buffer = ByteData.view(data.buffer);
    final reader = BinaryReader(buffer);
    
    {% if account.discriminator %}
    // Validate the discriminator
    final discriminator = reader.readFixedArray(8);
    if (!listEquals(discriminator, {{ account.name | pascalCase }}.discriminator)) {
      throw FormatException('Invalid account discriminator');
    }
    {% endif %}
    
    return {{ account.name | pascalCase }}.fromBorsh(reader);
  }

  /// Serializes this account to its bytes representation.
  Uint8List toBytes() {
    final writer = BinaryWriter();
    
    {% if account.discriminator %}
    // Write discriminator
    writer.writeFixedArray({{ account.name | pascalCase }}.discriminator);
    {% endif %}
    
    // Write account data
    toBorsh(writer);
    
    return writer.toBytes();
  }

  {% if pda %}
  /// Find the program address (PDA) for this account.
  ///
  /// Returns a tuple containing the PDA and bump seed.
  static (PublicKey, int) findProgramAddress(
    {% for seed in seeds %}
    {% if seed.kind === 'variablePdaSeedNode' %}
    {{ seed.typeManifest.type }} {{ seed.name | camelCase }},
    {% endif %}
    {% endfor %}
  ) {
    return PublicKey.findProgramAddressSync(
      [
        {% for seed in seeds %}
        {% if seed.kind === 'constantPdaSeedNode' and seed.value.kind === 'programIdValueNode' %}
        {{ program.name | pascalCase }}Program.programId.toBytes(),
        {% elif seed.kind === 'constantPdaSeedNode' %}
        utf8.encode('{{ seed.valueManifest.render | replace("\"", "") }}'),
        {% elif seed.kind === 'variablePdaSeedNode' and seed.resolvedType.kind === 'publicKeyTypeNode' %}
        {{ seed.name | camelCase }}.toBytes(),
        {% elif seed.kind === 'variablePdaSeedNode' and seed.resolvedType.kind === 'bytesTypeNode' %}
        {{ seed.name | camelCase }},
        {% else %}
        utf8.encode({{ seed.name | camelCase }}.toString()),
        {% endif %}
        {% endfor %}
      ],
      {{ program.name | pascalCase }}Program.programId,
    );
  }
  {% endif %}

  /// Fetches a [{{ account.name | pascalCase }}] from the blockchain.
  static Future<{{ account.name | pascalCase }}> fetch(
    Connection connection,
    PublicKey address,
  ) async {
    final accountInfo = await connection.getAccountInfo(address);
    if (accountInfo == null) {
      throw AccountNotFoundError(address);
    }
    return fromBytes(accountInfo.data);
  }

  /// Fetches a [{{ account.name | pascalCase }}] from the blockchain if it exists.
  static Future<{{ account.name | pascalCase }}?> fetchNullable(
    Connection connection,
    PublicKey address,
  ) async {
    try {
      return await fetch(connection, address);
    } catch (e) {
      if (e is AccountNotFoundError) {
        return null;
      }
      rethrow;
    }
  }
}
{% endblock %}